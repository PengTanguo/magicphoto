<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å›¾ç‰‡è½¬åœºæ•ˆæœç¼–è¾‘å™¨</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 2.5rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .main-layout {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 30px;
        }

        /* å·¦ä¾§é¢„è§ˆåŒºåŸŸ */
        .preview-section {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 20px;
        }

        .upload-area {
            border: 3px dashed #667eea;
            border-radius: 10px;
            padding: 30px;
            text-align: center;
            margin-bottom: 20px;
            background: white;
            transition: all 0.3s;
        }

        .upload-area:hover {
            border-color: #764ba2;
            background: #f8f9ff;
        }

        .upload-btn {
            display: inline-block;
            padding: 12px 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            transition: transform 0.3s;
        }

        .upload-btn:hover {
            transform: scale(1.05);
        }

        #fileInput {
            display: none;
        }

        .image-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
        }

        .image-item {
            position: relative;
            aspect-ratio: 1;
            border-radius: 8px;
            overflow: hidden;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.3s;
        }

        .image-item:hover {
            border-color: #667eea;
            transform: scale(1.05);
        }

        .image-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .image-item .remove-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            background: rgba(255, 0, 0, 0.8);
            color: white;
            border: none;
            border-radius: 50%;
            width: 25px;
            height: 25px;
            cursor: pointer;
            display: none;
        }

        .image-item:hover .remove-btn {
            display: block;
        }

        .preview-canvas-container {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        #previewCanvas {
            width: 100%;
            max-width: 800px;
            height: 450px;
            border-radius: 10px;
            background: #000;
            display: block;
            margin: 0 auto;
        }

        .controls {
            margin-top: 20px;
            display: flex;
            justify-content: center;
            gap: 15px;
        }

        .control-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 25px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }

        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* å³ä¾§é…ç½®é¢æ¿ */
        .config-section {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 20px;
            height: fit-content;
            position: sticky;
            top: 20px;
        }

        .config-group {
            margin-bottom: 25px;
        }

        .config-group h3 {
            color: #333;
            margin-bottom: 15px;
            font-size: 18px;
            border-bottom: 2px solid #667eea;
            padding-bottom: 8px;
        }

        .transition-effects {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .effect-btn {
            padding: 10px;
            border: 2px solid #e0e0e0;
            background: white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 14px;
        }

        .effect-btn:hover {
            border-color: #667eea;
            background: #f8f9ff;
        }

        .effect-btn.active {
            border-color: #764ba2;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .config-item {
            margin-bottom: 15px;
        }

        .config-item label {
            display: block;
            color: #555;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .config-item input[type="range"] {
            width: 100%;
            height: 6px;
            background: #e0e0e0;
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }

        .config-item input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 50%;
            cursor: pointer;
        }

        .config-item input[type="number"],
        .config-item select {
            width: 100%;
            padding: 8px 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        .config-item input[type="number"]:focus,
        .config-item select:focus {
            border-color: #667eea;
            outline: none;
        }

        .value-display {
            display: inline-block;
            margin-left: 10px;
            color: #667eea;
            font-weight: bold;
        }

        .generate-btn {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #00c851 0%, #00a846 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 20px;
        }

        .generate-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 200, 81, 0.3);
        }

        .progress-bar {
            display: none;
            margin-top: 20px;
        }

        .progress-bar.active {
            display: block;
        }

        .progress-track {
            width: 100%;
            height: 10px;
            background: #e0e0e0;
            border-radius: 5px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 5px;
            transition: width 0.3s;
            width: 0%;
        }

        .progress-text {
            text-align: center;
            margin-top: 10px;
            color: #666;
            font-size: 14px;
        }

        /* è½¬åœºæ•ˆæœæ ·å¼ */
        .canvas-wrapper {
            position: relative;
            width: 100%;
            height: 450px;
            overflow: hidden;
            background: #000;
            border-radius: 10px;
        }

        .transition-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
<div class="container">
    <h1>ğŸ¬ å›¾ç‰‡è½¬åœºæ•ˆæœç¼–è¾‘å™¨</h1>

    <div class="main-layout">
        <!-- å·¦ä¾§é¢„è§ˆåŒºåŸŸ -->
        <div class="preview-section">
            <div class="upload-area">
                <label for="fileInput" class="upload-btn">
                    ğŸ“ ä¸Šä¼ å›¾ç‰‡
                </label>
                <input type="file" id="fileInput" multiple accept="image/*">
                <p style="margin-top: 15px; color: #666;">æ”¯æŒå¤šé€‰ï¼Œå¯æ‹–æ‹½ä¸Šä¼ </p>
            </div>

            <div class="image-list" id="imageList"></div>

            <div class="preview-canvas-container">
                <div class="canvas-wrapper">
                    <canvas id="previewCanvas"></canvas>
                </div>
            </div>

            <div class="controls">
                <button class="control-btn" id="playBtn">â–¶ï¸ æ’­æ”¾</button>
                <button class="control-btn" id="pauseBtn">â¸ï¸ æš‚åœ</button>
                <button class="control-btn" id="stopBtn">â¹ï¸ åœæ­¢</button>
            </div>
        </div>

        <!-- å³ä¾§é…ç½®é¢æ¿ -->
        <div class="config-section">
            <div class="config-group">
                <h3>ğŸ¨ è½¬åœºæ•ˆæœ</h3>
                <div class="transition-effects">
                    <button class="effect-btn active" data-effect="fade">æ·¡å…¥æ·¡å‡º</button>
                    <button class="effect-btn" data-effect="gradient">æ¸å˜è¿‡æ¸¡</button>
                    <button class="effect-btn" data-effect="wipe-left">å·¦æ“¦é™¤</button>
                    <button class="effect-btn" data-effect="wipe-right">å³æ“¦é™¤</button>
                    <button class="effect-btn" data-effect="wipe-up">ä¸Šæ“¦é™¤</button>
                    <button class="effect-btn" data-effect="wipe-down">ä¸‹æ“¦é™¤</button>
                    <button class="effect-btn" data-effect="zoom-in">æ”¾å¤§åˆ‡æ¢</button>
                    <button class="effect-btn" data-effect="zoom-out">ç¼©å°åˆ‡æ¢</button>
                    <button class="effect-btn" data-effect="flip-h">æ°´å¹³ç¿»è½¬</button>
                    <button class="effect-btn" data-effect="flip-v">å‚ç›´ç¿»è½¬</button>
                    <button class="effect-btn" data-effect="fragment">ç¢ç‰‡åŒ–</button>
                    <button class="effect-btn" data-effect="rotate">æ—‹è½¬åˆ‡æ¢</button>
                </div>
            </div>

            <div class="config-group">
                <h3>âš™ï¸ å‚æ•°è®¾ç½®</h3>

                <div class="config-item">
                    <label>æ¯å¼ å›¾ç‰‡æ—¶é•¿ï¼ˆç§’ï¼‰
                        <span class="value-display" id="durationValue">3</span>
                    </label>
                    <input type="range" id="imageDuration" min="1" max="10" value="3" step="0.5">
                </div>

                <div class="config-item">
                    <label>è½¬åœºæ—¶é•¿ï¼ˆç§’ï¼‰
                        <span class="value-display" id="transitionValue">1</span>
                    </label>
                    <input type="range" id="transitionDuration" min="0.5" max="3" value="1" step="0.1">
                </div>

                <div class="config-item">
                    <label>è¾“å‡ºåˆ†è¾¨ç‡</label>
                    <select id="resolution">
                        <option value="1920x1080">1920Ã—1080 (Full HD)</option>
                        <option value="1280x720" selected>1280Ã—720 (HD)</option>
                        <option value="854x480">854Ã—480 (SD)</option>
                        <option value="640x360">640Ã—360</option>
                    </select>
                </div>

                <div class="config-item">
                    <label>å¸§ç‡ (FPS)</label>
                    <select id="frameRate">
                        <option value="24">24 FPS</option>
                        <option value="30" selected>30 FPS</option>
                        <option value="60">60 FPS</option>
                    </select>
                </div>

                <div class="config-item">
                    <label>è¾“å‡ºæ ¼å¼</label>
                    <select id="outputFormat">
                        <option value="mp4">MP4</option>
                        <option value="webm">WebM</option>
                        <option value="gif">GIF</option>
                    </select>
                </div>
            </div>

            <button class="generate-btn" id="generateBtn">
                ğŸ¥ ç”Ÿæˆè§†é¢‘
            </button>

            <div class="progress-bar" id="progressBar">
                <div class="progress-track">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="progress-text" id="progressText">å¤„ç†ä¸­... 0%</div>
            </div>
        </div>
    </div>
</div>

<script>
    class ImageTransitionEditor {
        constructor() {
            this.images = [];
            this.currentImageIndex = 0;
            this.isPlaying = false;
            this.animationFrame = null;
            this.currentEffect = 'fade';
            this.imageDuration = 3000;
            this.transitionDuration = 1000;
            this.lastTime = 0;
            this.currentTime = 0;

            this.canvas = document.getElementById('previewCanvas');
            this.ctx = this.canvas.getContext('2d');

            this.init();
        }

        init() {
            this.setupEventListeners();
            this.setupCanvas();
        }

        setupCanvas() {
            // è®¾ç½®ç”»å¸ƒå°ºå¯¸
            const container = this.canvas.parentElement;
            const rect = container.getBoundingClientRect();
            this.canvas.width = 1280;
            this.canvas.height = 720;
        }

        setupEventListeners() {
            // æ–‡ä»¶ä¸Šä¼ 
            const fileInput = document.getElementById('fileInput');
            const uploadArea = document.querySelector('.upload-area');

            fileInput.addEventListener('change', (e) => this.handleFileSelect(e));

            // æ‹–æ‹½ä¸Šä¼ 
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadArea.style.background = '#f0f0ff';
            });

            uploadArea.addEventListener('dragleave', () => {
                uploadArea.style.background = 'white';
            });

            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadArea.style.background = 'white';
                const files = Array.from(e.dataTransfer.files);
                this.loadImages(files);
            });

            // è½¬åœºæ•ˆæœé€‰æ‹©
            document.querySelectorAll('.effect-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.effect-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    this.currentEffect = btn.dataset.effect;
                    if (this.images.length > 0) {
                        this.restartPreview();
                    }
                });
            });

            // æ’­æ”¾æ§åˆ¶
            document.getElementById('playBtn').addEventListener('click', () => this.play());
            document.getElementById('pauseBtn').addEventListener('click', () => this.pause());
            document.getElementById('stopBtn').addEventListener('click', () => this.stop());

            // å‚æ•°è°ƒæ•´
            const durationSlider = document.getElementById('imageDuration');
            durationSlider.addEventListener('input', (e) => {
                this.imageDuration = e.target.value * 1000;
                document.getElementById('durationValue').textContent = e.target.value;
            });

            const transitionSlider = document.getElementById('transitionDuration');
            transitionSlider.addEventListener('input', (e) => {
                this.transitionDuration = e.target.value * 1000;
                document.getElementById('transitionValue').textContent = e.target.value;
            });

            // ç”Ÿæˆè§†é¢‘
            document.getElementById('generateBtn').addEventListener('click', () => this.generateVideo());
        }

        handleFileSelect(e) {
            const files = Array.from(e.target.files);
            this.loadImages(files);
        }

        loadImages(files) {
            const imageFiles = files.filter(file => file.type.startsWith('image/'));

            imageFiles.forEach(file => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        this.images.push({
                            element: img,
                            src: e.target.result,
                            name: file.name
                        });
                        this.updateImageList();
                        if (this.images.length === 1) {
                            this.drawImage(0);
                        }
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            });
        }

        updateImageList() {
            const imageList = document.getElementById('imageList');
            imageList.innerHTML = '';

            this.images.forEach((img, index) => {
                const item = document.createElement('div');
                item.className = 'image-item';
                item.innerHTML = `
                    <img src="${img.src}" alt="${img.name}">
                    <button class="remove-btn" data-index="${index}">Ã—</button>
                `;

                item.querySelector('.remove-btn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.removeImage(index);
                });

                item.addEventListener('click', () => {
                    this.currentImageIndex = index;
                    this.drawImage(index);
                });

                imageList.appendChild(item);
            });
        }

        removeImage(index) {
            this.images.splice(index, 1);
            this.updateImageList();
            if (this.currentImageIndex >= this.images.length) {
                this.currentImageIndex = Math.max(0, this.images.length - 1);
            }
            if (this.images.length > 0) {
                this.drawImage(this.currentImageIndex);
            } else {
                this.clearCanvas();
            }
        }

        clearCanvas() {
            this.ctx.fillStyle = '#000';
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        }

        drawImage(index, alpha = 1) {
            if (index < 0 || index >= this.images.length) return;

            const img = this.images[index].element;
            this.ctx.save();
            this.ctx.globalAlpha = alpha;

            // ä¿æŒå›¾ç‰‡æ¯”ä¾‹å¹¶å±…ä¸­
            const scale = Math.min(
                this.canvas.width / img.width,
                this.canvas.height / img.height
            );

            const w = img.width * scale;
            const h = img.height * scale;
            const x = (this.canvas.width - w) / 2;
            const y = (this.canvas.height - h) / 2;

            this.clearCanvas();
            this.ctx.drawImage(img, x, y, w, h);
            this.ctx.restore();
        }

        play() {
            if (this.images.length < 2) {
                alert('è¯·è‡³å°‘ä¸Šä¼ 2å¼ å›¾ç‰‡');
                return;
            }

            this.isPlaying = true;
            this.lastTime = performance.now();
            this.animate();
        }

        pause() {
            this.isPlaying = false;
            if (this.animationFrame) {
                cancelAnimationFrame(this.animationFrame);
            }
        }

        stop() {
            this.isPlaying = false;
            this.currentImageIndex = 0;
            this.currentTime = 0;
            if (this.animationFrame) {
                cancelAnimationFrame(this.animationFrame);
            }
            if (this.images.length > 0) {
                this.drawImage(0);
            }
        }

        restartPreview() {
            this.stop();
            this.play();
        }

        animate(timestamp) {
            if (!this.isPlaying) return;

            if (!timestamp) timestamp = performance.now();
            const deltaTime = timestamp - this.lastTime;
            this.lastTime = timestamp;
            this.currentTime += deltaTime;

            const totalDuration = this.imageDuration + this.transitionDuration;
            const cycleTime = this.currentTime % (totalDuration * this.images.length);
            const currentCycle = Math.floor(cycleTime / totalDuration);
            const cycleProgress = (cycleTime % totalDuration) / totalDuration;

            this.currentImageIndex = currentCycle;
            const nextIndex = (currentCycle + 1) % this.images.length;

            // åˆ¤æ–­æ˜¯å¦åœ¨è½¬åœºé˜¶æ®µ
            const transitionStart = this.imageDuration / totalDuration;

            if (cycleProgress > transitionStart) {
                // è½¬åœºé˜¶æ®µ
                const transitionProgress = (cycleProgress - transitionStart) / (1 - transitionStart);
                this.applyTransition(this.currentImageIndex, nextIndex, transitionProgress);
            } else {
                // æ˜¾ç¤ºå½“å‰å›¾ç‰‡
                this.drawImage(this.currentImageIndex);
            }

            this.animationFrame = requestAnimationFrame((t) => this.animate(t));
        }

        applyTransition(fromIndex, toIndex, progress) {
            const fromImg = this.images[fromIndex].element;
            const toImg = this.images[toIndex].element;

            this.clearCanvas();

            switch (this.currentEffect) {
                case 'fade':
                    this.fadeTransition(fromImg, toImg, progress);
                    break;
                case 'gradient':
                    this.gradientTransition(fromImg, toImg, progress);
                    break;
                case 'wipe-left':
                    this.wipeTransition(fromImg, toImg, progress, 'left');
                    break;
                case 'wipe-right':
                    this.wipeTransition(fromImg, toImg, progress, 'right');
                    break;
                case 'wipe-up':
                    this.wipeTransition(fromImg, toImg, progress, 'up');
                    break;
                case 'wipe-down':
                    this.wipeTransition(fromImg, toImg, progress, 'down');
                    break;
                case 'zoom-in':
                    this.zoomTransition(fromImg, toImg, progress, 'in');
                    break;
                case 'zoom-out':
                    this.zoomTransition(fromImg, toImg, progress, 'out');
                    break;
                case 'flip-h':
                    this.flipTransition(fromImg, toImg, progress, 'horizontal');
                    break;
                case 'flip-v':
                    this.flipTransition(fromImg, toImg, progress, 'vertical');
                    break;
                case 'fragment':
                    this.fragmentTransition(fromImg, toImg, progress);
                    break;
                case 'rotate':
                    this.rotateTransition(fromImg, toImg, progress);
                    break;
                default:
                    this.fadeTransition(fromImg, toImg, progress);
            }
        }

        fadeTransition(fromImg, toImg, progress) {
            // ç»˜åˆ¶æ¸éšçš„å›¾ç‰‡
            this.ctx.save();
            this.ctx.globalAlpha = 1 - progress;
            this.drawImageCentered(fromImg);
            this.ctx.restore();

            // ç»˜åˆ¶æ¸æ˜¾çš„å›¾ç‰‡
            this.ctx.save();
            this.ctx.globalAlpha = progress;
            this.drawImageCentered(toImg);
            this.ctx.restore();
        }

        gradientTransition(fromImg, toImg, progress) {
            // å…ˆç»˜åˆ¶ç›®æ ‡å›¾ç‰‡
            this.drawImageCentered(toImg);

            // åˆ›å»ºæ¸å˜é®ç½©
            this.ctx.save();
            const gradient = this.ctx.createLinearGradient(
                this.canvas.width * progress, 0,
                this.canvas.width * (progress - 1), 0
            );
            gradient.addColorStop(0, 'rgba(0,0,0,0)');
            gradient.addColorStop(0.5, 'rgba(0,0,0,0.5)');
            gradient.addColorStop(1, 'rgba(0,0,0,1)');

            this.ctx.globalCompositeOperation = 'destination-in';
            this.ctx.fillStyle = gradient;
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

            this.ctx.globalCompositeOperation = 'destination-over';
            this.drawImageCentered(fromImg);
            this.ctx.restore();
        }

        wipeTransition(fromImg, toImg, progress, direction) {
            this.ctx.save();

            // å…ˆç»˜åˆ¶ç›®æ ‡å›¾ç‰‡
            this.drawImageCentered(toImg);

            // è®¾ç½®æ“¦é™¤åŒºåŸŸ
            this.ctx.globalCompositeOperation = 'destination-over';

            switch (direction) {
                case 'left':
                    this.ctx.rect(
                        this.canvas.width * progress, 0,
                        this.canvas.width, this.canvas.height
                    );
                    break;
                case 'right':
                    this.ctx.rect(
                        0, 0,
                        this.canvas.width * (1 - progress), this.canvas.height
                    );
                    break;
                case 'up':
                    this.ctx.rect(
                        0, this.canvas.height * progress,
                        this.canvas.width, this.canvas.height
                    );
                    break;
                case 'down':
                    this.ctx.rect(
                        0, 0,
                        this.canvas.width, this.canvas.height * (1 - progress)
                    );
                    break;
            }

            this.ctx.clip();
            this.drawImageCentered(fromImg);
            this.ctx.restore();
        }

        zoomTransition(fromImg, toImg, progress, type) {
            this.ctx.save();

            if (type === 'in') {
                // æ”¾å¤§åˆ‡æ¢
                const scale1 = 1 + progress * 0.5;
                this.ctx.globalAlpha = 1 - progress;
                this.ctx.translate(this.canvas.width / 2, this.canvas.height / 2);
                this.ctx.scale(scale1, scale1);
                this.ctx.translate(-this.canvas.width / 2, -this.canvas.height / 2);
                this.drawImageCentered(fromImg);

                this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                const scale2 = 0.5 + progress * 0.5;
                this.ctx.globalAlpha = progress;
                this.ctx.translate(this.canvas.width / 2, this.canvas.height / 2);
                this.ctx.scale(scale2, scale2);
                this.ctx.translate(-this.canvas.width / 2, -this.canvas.height / 2);
                this.drawImageCentered(toImg);
            } else {
                // ç¼©å°åˆ‡æ¢
                const scale1 = 1 - progress * 0.5;
                this.ctx.globalAlpha = 1 - progress;
                this.ctx.translate(this.canvas.width / 2, this.canvas.height / 2);
                this.ctx.scale(scale1, scale1);
                this.ctx.translate(-this.canvas.width / 2, -this.canvas.height / 2);
                this.drawImageCentered(fromImg);

                this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                this.ctx.globalAlpha = progress;
                this.drawImageCentered(toImg);
            }

            this.ctx.restore();
        }
            flipTransition(fromImg, toImg, progress, direction) {
                this.ctx.save();

                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;

                if (direction === 'horizontal') {
                    // æ°´å¹³ç¿»è½¬
                    if (progress < 0.5) {
                        const scale = Math.cos(progress * Math.PI);
                        this.ctx.translate(centerX, centerY);
                        this.ctx.scale(scale, 1);
                        this.ctx.translate(-centerX, -centerY);
                        this.drawImageCentered(fromImg);
                    } else {
                        const scale = Math.cos((1 - progress) * Math.PI);
                        this.ctx.translate(centerX, centerY);
                        this.ctx.scale(scale, 1);
                        this.ctx.translate(-centerX, -centerY);
                        this.drawImageCentered(toImg);
                    }
                } else {
                    // å‚ç›´ç¿»è½¬
                    if (progress < 0.5) {
                        const scale = Math.cos(progress * Math.PI);
                        this.ctx.translate(centerX, centerY);
                        this.ctx.scale(1, scale);
                        this.ctx.translate(-centerX, -centerY);
                        this.drawImageCentered(fromImg);
                    } else {
                        const scale = Math.cos((1 - progress) * Math.PI);
                        this.ctx.translate(centerX, centerY);
                        this.ctx.scale(1, scale);
                        this.ctx.translate(-centerX, -centerY);
                        this.drawImageCentered(toImg);
                    }
                }

                this.ctx.restore();
            }

            fragmentTransition(fromImg, toImg, progress) {
                const rows = 8;
                const cols = 8;
                const cellWidth = this.canvas.width / cols;
                const cellHeight = this.canvas.height / rows;

                // å…ˆç»˜åˆ¶å®Œæ•´çš„ç›®æ ‡å›¾ç‰‡
                this.drawImageCentered(toImg);

                // ç»˜åˆ¶ç¢ç‰‡åŒ–çš„æºå›¾ç‰‡
                this.ctx.save();

                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        const delay = (row + col) / (rows + cols);
                        const localProgress = Math.max(0, Math.min(1, (progress - delay * 0.5) * 2));

                        if (localProgress < 1) {
                            const x = col * cellWidth;
                            const y = row * cellHeight;

                            // æ·»åŠ éšæœºåç§»å’Œæ—‹è½¬
                            const offsetX = (Math.random() - 0.5) * cellWidth * localProgress;
                            const offsetY = (Math.random() - 0.5) * cellHeight * localProgress;
                            const rotation = (Math.random() - 0.5) * Math.PI * localProgress;
                            const scale = 1 - localProgress * 0.5;

                            this.ctx.save();
                            this.ctx.globalAlpha = 1 - localProgress;
                            this.ctx.translate(x + cellWidth / 2 + offsetX, y + cellHeight / 2 + offsetY);
                            this.ctx.rotate(rotation);
                            this.ctx.scale(scale, scale);

                            // è£å‰ªå¹¶ç»˜åˆ¶ç¢ç‰‡
                            this.ctx.drawImage(
                                this.createImageFragment(fromImg, col, row, cols, rows),
                                -cellWidth / 2, -cellHeight / 2,
                                cellWidth, cellHeight
                            );

                            this.ctx.restore();
                        }
                    }
                }

                this.ctx.restore();
            }

            createImageFragment(img, col, row, cols, rows) {
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');

                const cellWidth = img.width / cols;
                const cellHeight = img.height / rows;

                tempCanvas.width = cellWidth;
                tempCanvas.height = cellHeight;

                tempCtx.drawImage(
                    img,
                    col * cellWidth, row * cellHeight,
                    cellWidth, cellHeight,
                    0, 0,
                    cellWidth, cellHeight
                );

                return tempCanvas;
            }

            rotateTransition(fromImg, toImg, progress) {
                this.ctx.save();

                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;

                // æ—‹è½¬æ¶ˆå¤±çš„å›¾ç‰‡
                this.ctx.globalAlpha = 1 - progress;
                this.ctx.translate(centerX, centerY);
                this.ctx.rotate(progress * Math.PI / 2);
                this.ctx.scale(1 - progress * 0.5, 1 - progress * 0.5);
                this.ctx.translate(-centerX, -centerY);
                this.drawImageCentered(fromImg);

                // æ—‹è½¬å‡ºç°çš„å›¾ç‰‡
                this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                this.ctx.globalAlpha = progress;
                this.ctx.translate(centerX, centerY);
                this.ctx.rotate(-Math.PI / 2 + progress * Math.PI / 2);
                this.ctx.scale(progress, progress);
                this.ctx.translate(-centerX, -centerY);
                this.drawImageCentered(toImg);

                this.ctx.restore();
            }

            drawImageCentered(img) {
                const scale = Math.min(
                    this.canvas.width / img.width,
                    this.canvas.height / img.height
                );

                const w = img.width * scale;
                const h = img.height * scale;
                const x = (this.canvas.width - w) / 2;
                const y = (this.canvas.height - h) / 2;

                this.ctx.drawImage(img, x, y, w, h);
            }

            async generateVideo() {
                if (this.images.length < 2) {
                    alert('è¯·è‡³å°‘ä¸Šä¼ 2å¼ å›¾ç‰‡æ‰èƒ½ç”Ÿæˆè§†é¢‘');
                    return;
                }

                const progressBar = document.getElementById('progressBar');
                const progressFill = document.getElementById('progressFill');
                const progressText = document.getElementById('progressText');
                const generateBtn = document.getElementById('generateBtn');

                // è·å–é…ç½®å‚æ•°
                const resolution = document.getElementById('resolution').value.split('x');
                const frameRate = parseInt(document.getElementById('frameRate').value);
                const format = document.getElementById('outputFormat').value;

                // æ˜¾ç¤ºè¿›åº¦æ¡
                progressBar.classList.add('active');
                generateBtn.disabled = true;

                // åˆ›å»ºä¸´æ—¶ç”»å¸ƒç”¨äºæ¸²æŸ“
                const renderCanvas = document.createElement('canvas');
                renderCanvas.width = parseInt(resolution[0]);
                renderCanvas.height = parseInt(resolution[1]);
                const renderCtx = renderCanvas.getContext('2d');

                // å‡†å¤‡å¸§æ•°æ®
                const frames = [];
                const totalDuration = (this.imageDuration + this.transitionDuration) * this.images.length;
                const totalFrames = Math.floor(totalDuration * frameRate / 1000);

                // æ¨¡æ‹Ÿç”Ÿæˆè¿‡ç¨‹
                for (let frame = 0; frame < totalFrames; frame++) {
                    const timestamp = (frame / frameRate) * 1000;
                    const progress = (frame / totalFrames) * 100;

                    // æ›´æ–°è¿›åº¦
                    progressFill.style.width = progress + '%';
                    progressText.textContent = `å¤„ç†ä¸­... ${Math.round(progress)}%`;

                    // æ¸²æŸ“å½“å‰å¸§
                    await this.renderFrame(renderCanvas, renderCtx, timestamp);

                    // æ”¶é›†å¸§æ•°æ®ï¼ˆè¿™é‡Œä»…ä½œæ¼”ç¤ºï¼Œå®é™…éœ€è¦ä½¿ç”¨ä¸“é—¨çš„è§†é¢‘ç¼–ç åº“ï¼‰
                    if (format === 'gif' && frame % 2 === 0) { // GIFé‡‡æ ·
                        frames.push(renderCanvas.toDataURL('image/png'));
                    }

                    // è®©UIæœ‰æ—¶é—´æ›´æ–°
                    if (frame % 10 === 0) {
                        await new Promise(resolve => setTimeout(resolve, 0));
                    }
                }

                // ç”Ÿæˆè§†é¢‘æ–‡ä»¶ï¼ˆè¿™é‡Œæ¨¡æ‹Ÿç”Ÿæˆï¼‰
                progressText.textContent = 'æ­£åœ¨ç¼–ç è§†é¢‘...';
                await new Promise(resolve => setTimeout(resolve, 1000));

                // åˆ›å»ºä¸‹è½½é“¾æ¥
                if (format === 'gif') {
                    // ç®€å•çš„GIFæ¼”ç¤ºï¼ˆå®é™…éœ€è¦gif.jsç­‰åº“ï¼‰
                    this.createDownloadLink(frames[0], 'animation.gif');
                } else {
                    // æ¨¡æ‹Ÿè§†é¢‘ç”Ÿæˆ
                    const videoBlob = await this.createVideoBlob(frames, format);
                    this.createDownloadLink(URL.createObjectURL(videoBlob), `video.${format}`);
                }

                // å®Œæˆ
                progressFill.style.width = '100%';
                progressText.textContent = 'è§†é¢‘ç”Ÿæˆå®Œæˆï¼';
                generateBtn.disabled = false;

                setTimeout(() => {
                    progressBar.classList.remove('active');
                    progressFill.style.width = '0%';
                }, 2000);
            }

            async renderFrame(canvas, ctx, timestamp) {
                const totalDuration = this.imageDuration + this.transitionDuration;
                const cycleTime = timestamp % (totalDuration * this.images.length);
                const currentCycle = Math.floor(cycleTime / totalDuration);
                const cycleProgress = (cycleTime % totalDuration) / totalDuration;

                const currentIndex = currentCycle;
                const nextIndex = (currentCycle + 1) % this.images.length;

                // æ¸…ç©ºç”»å¸ƒ
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // ä¸´æ—¶æ›¿æ¢ç”»å¸ƒå’Œä¸Šä¸‹æ–‡
                const originalCanvas = this.canvas;
                const originalCtx = this.ctx;
                this.canvas = canvas;
                this.ctx = ctx;

                const transitionStart = this.imageDuration / totalDuration;

                if (cycleProgress > transitionStart) {
                    const transitionProgress = (cycleProgress - transitionStart) / (1 - transitionStart);
                    this.applyTransition(currentIndex, nextIndex, transitionProgress);
                } else {
                    this.drawImage(currentIndex);
                }

                // æ¢å¤åŸå§‹ç”»å¸ƒå’Œä¸Šä¸‹æ–‡
                this.canvas = originalCanvas;
                this.ctx = originalCtx;
            }

            async createVideoBlob(frames, format) {
                // è¿™é‡Œåº”è¯¥ä½¿ç”¨å®é™…çš„è§†é¢‘ç¼–ç åº“ï¼ˆå¦‚ffmpeg.jsï¼‰
                // ç°åœ¨åªæ˜¯åˆ›å»ºä¸€ä¸ªæ¨¡æ‹Ÿçš„Blob
                const dummyData = new Uint8Array([0, 1, 2, 3, 4, 5]);
                return new Blob([dummyData], { type: `video/${format}` });
            }

            createDownloadLink(url, filename) {
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.style.display = 'none';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
            }
        }

        // åˆå§‹åŒ–ç¼–è¾‘å™¨
        const editor = new ImageTransitionEditor();

        // æ·»åŠ ä¸€äº›é¢å¤–çš„UIäº¤äº’
        document.addEventListener('DOMContentLoaded', () => {
            // æ·»åŠ å¿«æ·é”®æ”¯æŒ
            document.addEventListener('keydown', (e) => {
                if (e.code === 'Space' && e.target.tagName !== 'INPUT') {
                    e.preventDefault();
                    if (editor.isPlaying) {
                        editor.pause();
                    } else {
                        editor.play();
                    }
                }

                if (e.code === 'Escape') {
                    editor.stop();
                }
            });

            // æ·»åŠ æç¤ºä¿¡æ¯
            const tips = [
                'ç©ºæ ¼é”®ï¼šæ’­æ”¾/æš‚åœ',
                'ESCé”®ï¼šåœæ­¢æ’­æ”¾',
                'æ”¯æŒæ‹–æ‹½ä¸Šä¼ å›¾ç‰‡',
                'å¯ä»¥è°ƒæ•´è½¬åœºæ—¶é•¿è·å¾—ä¸åŒæ•ˆæœ'
            ];

            // åˆ›å»ºæç¤ºå®¹å™¨
            const tipsContainer = document.createElement('div');
            tipsContainer.style.cssText = `
                position: fixed;
                bottom: 20px;
                right: 20px;
                background: rgba(0, 0, 0, 0.8);
                color: white;
                padding: 15px;
                border-radius: 10px;
                font-size: 14px;
                max-width: 250px;
                transition: opacity 0.3s;
                z-index: 1000;
            `;

            let currentTip = 0;
            const showTip = () => {
                tipsContainer.textContent = 'ğŸ’¡ ' + tips[currentTip];
                tipsContainer.style.opacity = '1';
                document.body.appendChild(tipsContainer);

                setTimeout(() => {
                    tipsContainer.style.opacity = '0';
                    setTimeout(() => {
                        if (tipsContainer.parentNode) {
                            tipsContainer.parentNode.removeChild(tipsContainer);
                        }
                        currentTip = (currentTip + 1) % tips.length;
                        setTimeout(showTip, 5000);
                    }, 300);
                }, 3000);
            };

            // å»¶è¿Ÿæ˜¾ç¤ºç¬¬ä¸€ä¸ªæç¤º
            setTimeout(showTip, 2000);
        });

        // æ·»åŠ åŠ è½½åŠ¨ç”»
        window.addEventListener('load', () => {
            const loader = document.createElement('div');
            loader.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 9999;
                transition: opacity 0.5s;
            `;

            loader.innerHTML = `
                <div style="text-align: center; color: white;">
                    <h2 style="font-size: 3rem; margin-bottom: 20px;">ğŸ¬</h2>
                    <p style="font-size: 1.5rem;">åŠ è½½ä¸­...</p>
                </div>
            `;

            document.body.appendChild(loader);

            setTimeout(() => {
                loader.style.opacity = '0';
                setTimeout(() => {
                    document.body.removeChild(loader);
                }, 500);
            }, 500);
        });
</script>
</body>
</html>
